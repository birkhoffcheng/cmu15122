/*
 * Text buffers as doubly linked lists.
 *
 * 15-122 Principles of Imperative Computation */

/*** Interface ***/

typedef struct dll_node dll;
struct dll_node {
	char data;
	dll* next;
	dll* prev;
};

typedef struct tbuf_header tbuf;
struct tbuf_header {
	dll* start;		// the fist node of the list (on the left)
	dll* cursor;	// the position where the cursor is displayed
	dll* end;		// the last node of the list (on the right)
};

bool is_tbuf(tbuf* B);
bool tbuf_at_left(tbuf* B);		// Returns true if the cursor is in leftmost position
bool tbuf_at_right(tbuf* B);	// Returns true if the cursor is in rightmost position
tbuf* tbuf_new();				// Creates a new, empty text buffer
void tbuf_forward(tbuf* B);		// Moves the cursor forward (right)
void tbuf_backward(tbuf* B);	// Moves the cursor backward (left)
void tbuf_insert(tbuf* B, char c);	// Insert a character before cursor
char tbuf_delete(tbuf* B);		// Remove character before cursor (and returns the deleted char)
int tbuf_row(tbuf* B);			// Returns the row of the cursor
int tbuf_col(tbuf* B);			// Returns the column of the cursor

/*** Implementation ***/

bool is_dll_segment(dll* a, dll* b) {
	if (a == NULL || b == NULL)	// if a or b is NULL
		return false;
	if (a == b)	// check if its length is one
		return true;
	return is_dll_segment(a->next, b) && is_dll_segment(a, b->prev);
}

bool is_tbuf(tbuf* B) {
	if (B == NULL || B->cursor == NULL || !is_dll_segment(B->start, B->end))
		return false;
	dll* current = B->start;
	if (current == NULL)
		return false;
	while (B->cursor != current && current != B->end && current->next != NULL)
		current = current->next;
	if (B->cursor != current)
		return false;
	else
		return true;
}

bool tbuf_at_left(tbuf* B)
//@requires is_tbuf(B);
{
	if (!is_tbuf(B))
		return false;
	return B->start->next == B->cursor;
}

bool tbuf_at_right(tbuf* B)
//@requires is_tbuf(B);
{
	if (!is_tbuf(B))
		return false;
	return B->end == B->cursor;
}

tbuf* tbuf_new()
//@ensures is_tbuf(B);
{
	tbuf* out = alloc(tbuf);
	out->start = alloc(dll);
	out->end = alloc(dll);
	out->start->next = end;
	out->end->prev = start;
	return out;
}

void tbuf_forward(tbuf* B)
//@requires is_tbuf(B);
{
	if (!is_tbuf(B) || tbuf_at_right(B))
		return;
	B->cursor = B->cursor->next;
	return;
}

void tbuf_backward(tbuf* B)
//@requires is_tbuf(B);
{
	if (!is_tbuf(B) || tbuf_at_left(B))
		return;
	if (tbuf_at_left(B))
		return;
	B->cursor = B->cursor->prev;
	return;
}

char tbuf_delete(tbuf* B)
//@requires is_tbuf(B);
{
	if (!is_tbuf(B) || tbuf_at_left(B))
		return '\0';
	dll* tmp = B->cursor->prev;
	tmp->prev->next = B->cursor;
	B->cursor->prev = tmp->prev;
	return tmp->data;
}

void tbuf_insert(tbuf* B, char c)
//@requires is_tbuf(B);
{
	if (!is_tbuf(B))
		return;
	dll* new = alloc(dll);
	new->data = c;
	B->cursor->prev->next = new;
	new->prev = B->cursor->prev;
	new->next = B->cursor;
	B->cursor->prev = new;
	return;
}
